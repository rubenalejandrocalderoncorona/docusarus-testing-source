name: Sync Documentation from Octoroute (OpenAI)

on:
  repository_dispatch:
    types: [docs-updated]
  workflow_dispatch:
    inputs:
      source_repo:
        description: 'Source repository (e.g., rubenalejandrocalderoncorona/testing-remote-docs)'
        required: true
        default: 'csie-ruben-test/Octoroute'
      source_ref:
        description: 'Source branch/commit'
        required: true
        default: 'main'

jobs:
  sync-docs:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout documentation repository (this repo)
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Checkout source repository
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.inputs.source_repo || github.event.client_payload.repository || 'csie-ruben-test/Octoroute' }}
          ref: ${{ github.event.inputs.source_ref || github.event.client_payload.ref || 'main' }}
          token: ${{ secrets.SOURCE_REPO_TOKEN }}
          path: source-repo
          fetch-depth: 2
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Get changed documentation files
        id: changed-files
        working-directory: source-repo
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            CHANGED_FILES=$(find documentation -name "*.md" -type f 2>/dev/null || echo "")
          else
            if [ -n "${{ github.event.client_payload.changed_files }}" ]; then
              CHANGED_FILES="${{ github.event.client_payload.changed_files }}"
              CHANGED_FILES=$(echo "$CHANGED_FILES" | xargs)
            else
              CHANGED_FILES_RAW=$(git diff --name-only HEAD~1 HEAD -- documentation/ 2>/dev/null || find documentation -name "*.md" -type f 2>/dev/null || echo "")
              CHANGED_FILES=$(echo "$CHANGED_FILES_RAW" | tr '\n' ' ')
            fi
          fi
          
          CHANGED_FILES_OUTPUT=$(echo "$CHANGED_FILES" | tr ' ' '\n')
          
          echo "files<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGED_FILES_OUTPUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "Changed files: $CHANGED_FILES"
      
      - name: Create analysis script
        run: |
          cat > analyze_docs.js << 'EOF'
          const fs = require('fs');
          const path = require('path');
          const https = require('https');

          const changedFiles = process.env.CHANGED_FILES.split('\n').filter(f => f.trim());
          const apiKey = process.env.OPENAI_API_KEY;
          const model = process.env.OPENAI_MODEL || 'gpt-4o-mini';
          
          if (!apiKey) {
            console.error('OPENAI_API_KEY is not set');
            process.exit(1);
          }

          async function callOpenAI(messages) {
            return new Promise((resolve, reject) => {
              const data = JSON.stringify({
                model: model,
                messages: messages,
                temperature: 0.3,
                max_tokens: 300,
                response_format: { type: "json_object" }
              });

              const options = {
                hostname: 'api.openai.com',
                port: 443,
                path: '/v1/chat/completions',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': 'Bearer ' + apiKey,
                  'Content-Length': data.length
                }
              };

              const req = https.request(options, (res) => {
                let body = '';
                
                res.on('data', (chunk) => {
                  body += chunk;
                });
                
                res.on('end', () => {
                  try {
                    const response = JSON.parse(body);
                    if (response.error) {
                      reject(new Error(response.error.message));
                    } else {
                      resolve(response);
                    }
                  } catch (error) {
                    reject(new Error('Failed to parse OpenAI response: ' + error.message));
                  }
                });
              });

              req.on('error', (error) => {
                reject(error);
              });

              req.write(data);
              req.end();
            });
          }

          async function analyzeWithOpenAI(filePath, content) {
            const messages = [
              {
                role: "system",
                content: "You are a documentation analyst. Respond ONLY with valid JSON."
              },
              {
                role: "user",
                content: 'Analyze this documentation change and determine if it is significant enough to sync to the documentation site. Consider: Is this a meaningful content change or just formatting/typos? Does it affect user understanding or functionality? Should this be synced immediately? File: ' + filePath + ' Content preview: ' + content.substring(0, 1500) + ' Respond with ONLY valid JSON in this exact format: {"should_sync": true, "reason": "brief explanation", "priority": "high"}'
              }
            ];

            try {
              console.log('Calling OpenAI API for ' + filePath + '...');
              
              const response = await callOpenAI(messages);
              
              if (!response.choices || !response.choices[0]) {
                throw new Error('Invalid response structure from OpenAI');
              }
              
              const content = response.choices[0].message.content;
              const parsedResponse = JSON.parse(content);
              
              console.log('OpenAI analysis for ' + filePath + ':', parsedResponse);
              return parsedResponse;
              
            } catch (error) {
              console.error('Error analyzing ' + filePath + ':', error.message);
              return { 
                should_sync: true, 
                reason: "Error during OpenAI analysis, syncing by default", 
                priority: "medium" 
              };
            }
          }

          async function processFiles() {
            const results = [];
            
            for (const file of changedFiles) {
              if (!file.endsWith('.md')) continue;
              
              const fullPath = path.join(process.cwd(), 'source-repo', file);
              if (!fs.existsSync(fullPath)) {
                console.log('File not found: ' + fullPath + ', skipping');
                continue;
              }
              
              const content = fs.readFileSync(fullPath, 'utf-8');
              const analysis = await analyzeWithOpenAI(file, content);
              
              results.push({
                file,
                analysis
              });
              
              console.log('Analysis for ' + file + ':', JSON.stringify(analysis, null, 2));
            }
            
            if (results.length === 0) {
              console.log('No markdown files to analyze');
            }
            
            fs.writeFileSync('analysis_results.json', JSON.stringify(results, null, 2));
          }

          processFiles().catch(error => {
            console.error('Fatal error:', error);
            fs.writeFileSync('analysis_results.json', JSON.stringify([], null, 2));
            process.exit(0);
          });
          EOF
      
      - name: Analyze changes with OpenAI
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_MODEL: ${{ secrets.OPENAI_MODEL || 'gpt-4o-mini' }}
          CHANGED_FILES: ${{ steps.changed-files.outputs.files }}
        run: node analyze_docs.js
      
      - name: Create sync script
        run: |
          cat > sync_docs.js << 'EOF'
          const fs = require('fs');
          const path = require('path');

          const analysisResults = JSON.parse(fs.readFileSync('analysis_results.json', 'utf-8'));
          
          const fileMapping = {
            'octoroute/documentation/ApprovalFlow.md': 'docs/services/octoroute/octoroute-approval-workflow.md',
            'octoroute/documentation/minikube-test.md': 'docs/services/octoroute/minikube-test.md',
          };

          function transformMarkdown(content, sourceFile, sourceRepo) {
            const sourceLink = 'https://github.com/' + sourceRepo + '/blob/main/' + sourceFile;
            const today = new Date().toISOString().split('T')[0];
            const timestamp = new Date().toISOString();
            
            const header = '---\n' +
              'source: ' + sourceLink + '\n' +
              'last_synced: ' + timestamp + '\n' +
              'automated: true\n' +
              '---\n\n' +
              '> **Source:** This documentation is automatically synced from [' + sourceFile + '](' + sourceLink + ')  \n' +
              '> **Last Updated:** ' + today + '\n\n';
            
            return header + content;
          }

          const sourceRepo = process.env.SOURCE_REPO || 'csie-ruben-test/Octoroute';
          let syncCount = 0;
          let skipCount = 0;

          analysisResults.forEach(function(item) {
            const file = item.file;
            const analysis = item.analysis;
            
            if (!analysis.should_sync) {
              console.log('Skipping ' + file + ': ' + analysis.reason);
              skipCount++;
              return;
            }

            const targetFile = fileMapping[file];
            if (!targetFile) {
              console.log('No mapping found for ' + file + ' - please add to fileMapping');
              return;
            }

            try {
              const sourcePath = path.join('source-repo', file);
              const content = fs.readFileSync(sourcePath, 'utf-8');
              const transformedContent = transformMarkdown(content, file, sourceRepo);
              
              fs.mkdirSync(path.dirname(targetFile), { recursive: true });
              fs.writeFileSync(targetFile, transformedContent);
              
              console.log('Synced ' + file + ' -> ' + targetFile + ' (Priority: ' + analysis.priority + ')');
              syncCount++;
            } catch (error) {
              console.error('Error syncing ' + file + ':', error.message);
            }
          });

          console.log('\nSummary: ' + syncCount + ' files synced, ' + skipCount + ' files skipped');
          
          const summary = {
            synced: syncCount,
            skipped: skipCount,
            details: analysisResults,
            timestamp: new Date().toISOString(),
            source_repo: sourceRepo
          };
          fs.writeFileSync('sync-summary.json', JSON.stringify(summary, null, 2));
          EOF
      
      - name: Sync documentation files
        env:
          SOURCE_REPO: ${{ github.event.inputs.source_repo || github.event.client_payload.repository || 'csie-ruben-test/Octoroute' }}
        run: node sync_docs.js
      
      - name: Commit and push changes
        run: |
          git config user.name "rubenalejandrocalderoncorona"
          git config user.email "rubenalejandrocalderoncorona@gmail.com"
          git add docs/
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          
          if command -v jq &> /dev/null; then
            SUMMARY=$(cat sync-summary.json | jq -r '.details | map("- \(.file): \(.analysis.reason)") | join("\n")')
          else
            SUMMARY="See sync-summary.json for details"
          fi
          
          COMMIT_REPO="${{ github.event.inputs.source_repo || github.event.client_payload.repository || 'csie-ruben-test/Octoroute' }}"
          COMMIT_SHA="${{ github.event.client_payload.sha || github.event.inputs.source_ref }}"
          
          git commit -m "docs: sync from $COMMIT_REPO

          Source commit: $COMMIT_SHA
          
          ${SUMMARY}"
          
          git push
